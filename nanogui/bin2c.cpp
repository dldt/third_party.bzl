#include <argparse/argparse.hpp>
#include <fmt/format.h>
#include <fmt/ostream.h>
#include <range/v3/algorithm/replace.hpp>
#include <range/v3/algorithm/transform.hpp>
#include <range/v3/view/transform.hpp>

#include <deque>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <iterator>

namespace stdfs = std::filesystem;

int fail(std::error_code ec) {
    fmt::print(std::cerr, "{}\n", ec.message());
    return EXIT_FAILURE;
}

int main(int argc, char** argv) {
    argparse::ArgumentParser program("bin2c");
    program.add_argument("-s", "--source-file")
        .help("the output C file container the resource embedding definition")
        .required()
        .action([](const std::string& path) { return stdfs::path(path); });

    program.add_argument("-i", "--include-file")
        .help("the output C header file container the resource embedding declaration")
        .required()
        .action([](const std::string& path) { return stdfs::path(path); });

    program.add_argument("files")
        .help("the resource files to embed")
        .action([](const std::string& path) { return stdfs::path(path); })
        .remaining();

    try {
        program.parse_args(argc, argv);
    } catch (const std::runtime_error& err) {
        fmt::print(std::cerr, "{0}\n", err.what());
        return fail(std::make_error_code(std::errc::invalid_argument));
    }

    const auto out_c_name = program.get<stdfs::path>("-s");
    const auto out_h_name = program.get<stdfs::path>("-i");
    std::vector<stdfs::path> resource_files;

    try {
        resource_files = program.get<std::vector<stdfs::path>>("files");
    } catch (std::logic_error& e) {
        fmt::print(std::cerr, "files argument: {0}\n", e.what());
        return fail(std::make_error_code(std::errc::invalid_argument));
    }

    std::ofstream out_h(out_h_name);
    std::ofstream out_c(out_c_name);

    auto relative_path = stdfs::relative(out_h_name, out_c_name.parent_path());

    fmt::print(out_c, "/* Autogenerated by bin2c */\n\n");
    fmt::print(out_c, "#include \"{}\"\n\n", relative_path.generic_string());

    fmt::print(out_h, "/* Autogenerated by bin2c */\n\n");
    fmt::print(out_h, "#pragma once\n");
    fmt::print(out_h, "#include <stdint.h>\n\n");
    fmt::print(out_h, "#ifdef __cplusplus\nextern \"C\" {{\n#endif\n\n");

    for (auto resource_file : resource_files) {
        std::ifstream in(resource_file, std::ios::binary);
        auto content = std::vector((std::istreambuf_iterator<char>(in)), std::istreambuf_iterator<char>());
        auto filename = resource_file.filename().string();
        ranges::replace(filename, '.', '_');
        ranges::replace(filename, ' ', '_');
        ranges::replace(filename, '-', '_');

        ranges::transform(filename, filename.begin(), [](auto c) { return std::tolower(c); });

        fmt::print(out_c, "uint8_t {0}[] = {{{1}}};\n\n", filename,
                   fmt::join(ranges::views::transform(content, [](auto c) { return std::to_string(c); }), ", "));

        fmt::print(out_c, "uint32_t {0}_size = sizeof({0});\n\n", filename);
        fmt::print(out_h, "extern uint8_t {0}[];\nextern uint32_t {0}_size; /* {1} */\n\n", filename, content.size());
    }

    fmt::print(out_h, "#ifdef __cplusplus\n}}\n#endif");

    return 0;
}
